// BizDoc PDF: safe template, page breaks, number formatting, progress bars,
// Bars + Lines + Composition (stacked) chart. No SVG; all helpers defined; no runtime deps beyond pdf-lib.
export default async function handler(req, res) {
  try {
    res.setHeader("Access-Control-Allow-Origin","*");
    res.setHeader("Access-Control-Allow-Methods","POST,OPTIONS");
    res.setHeader("Access-Control-Allow-Headers","Content-Type, Authorization");
    if (req.method === "OPTIONS") return res.status(204).end();
    if (req.method !== "POST") return res.status(405).json({ ok:false, error:"Use POST" });

    const { PDFDocument, StandardFonts, rgb } = await import("pdf-lib");

    const body = await readBody(req);
    const analysis = body?.analysis;
    const brand = body?.brand || { title: "BizDoc Analysis Report", company: "BizDoc" };
    if (!analysis || typeof analysis !== "object")
      return res.status(400).json({ ok:false, error:"Missing 'analysis' JSON" });

    // --- Setup
    const A4 = [595.28, 841.89];
    const pdf = await PDFDocument.create();
    let page = pdf.addPage(A4);
    const { width, height } = page.getSize();
    const margin = 48;
    const colW = width - margin*2;

    const font = await pdf.embedFont(StandardFonts.Helvetica);
    const bold = await pdf.embedFont(StandardFonts.HelveticaBold);

    let y = height - margin;

    // ---------- Helpers ----------
    function T(f, size, x, yy, text, color=rgb(0,0,0)){
      page.drawText(String(text ?? ""), { x, y: yy, size, font: f, color });
    }
    function HR(yy){
      page.drawRectangle({ x: margin, y: yy-0.5, width: colW, height: 0.8, color: rgb(0.85,0.85,0.85) });
    }
    function wrap(f, size, x, yy, w, text){
      const words = String(text ?? "").split(/\s+/);
      let line = "", cur = yy;
      for (const word of words) {
        const t = (line ? line+" " : "") + word;
        if (f.widthOfTextAtSize(t, size) > w) {
          page.drawText(line, { x, y: cur, size, font: f });
          cur -= size + 4; line = word;
        } else { line = t; }
      }
      if (line) { page.drawText(line, { x, y: cur, size, font: f }); cur -= size + 4; }
      return cur;
    }
    function textWidth(f, size, text){
      return f.widthOfTextAtSize(String(text ?? ""), size);
    }
    function drawLineSafe(pg, start, end, thickness=0.8, color=rgb(0.7,0.7,0.7)){
      try { pg.drawLine({ start, end, thickness, color }); }
      catch {
        const x1 = Math.min(start.x, end.x), x2 = Math.max(start.x, end.x);
        const y1 = Math.min(start.y, end.y), y2 = Math.max(start.y, end.y);
        const w = Math.max(1, x2 - x1), h = Math.max(1, y2 - y1);
        if (w > 1 && h > 1) {
          const steps = Math.ceil(Math.hypot(w,h)/4);
          for (let i=0;i<steps;i++){
            const t1 = i/steps, t2 = (i+1)/steps;
            const sx = start.x + (end.x-start.x)*t1;
            const sy = start.y + (end.y-start.y)*t1;
            const ex = start.x + (end.x-start.x)*t2;
            const ey = start.y + (end.y-start.y)*t2;
            const rx = Math.min(sx,ex), ry = Math.min(sy,ey);
            const rw = Math.max(1, Math.abs(ex-sx)), rh = Math.max(1, Math.abs(ey-sy));
            pg.drawRectangle({ x: rx, y: ry, width: rw, height: rh, color });
          }
        } else {
          pg.drawRectangle({ x: x1, y: y1, width: w, height: h, color });
        }
      }
    }
    function ensureSpace(need=100){
      if (y - need < margin + 60) {
        page = pdf.addPage(A4);
        y = height - margin;
        header(false);
      }
    }
    function header(first=true){
      T(bold, 18, margin, y, brand.title); y -= 12;
      HR(y); y -= 20;
      if (first) {
        const metaRight = `${(analysis.docType||"DOCUMENT").toString().toUpperCase()}  |  ${today()}`;
        T(font, 10, margin, y, "Generated by BizDoc");
        T(font, 10, width - margin - textWidth(font,10,metaRight), y, metaRight);
        y -= 16;
      }
    }
    function section(name){ ensureSpace(40); T(bold, 12, margin, y, name); y -= 14; }
    function progress(label, value01){
      const v = clamp01(value01);
      const H = 10, W = Math.min(280, colW);
      const yBar = y - H;
      T(font, 11, margin, y, `${label}: ${pct(v)}`);
      page.drawRectangle({ x: margin, y: yBar, width: W, height: H, borderColor: rgb(0.8,0.8,0.8), borderWidth: 1, color: rgb(1,1,1) });
      page.drawRectangle({ x: margin, y: yBar, width: W * v, height: H, color: rgb(0.2,0.2,0.2) });
      y -= H + 10;
    }
    function barsChart(title, items){
      const data = (Array.isArray(items) ? items : []).map(b => ({
        label: safeStr(b?.label).slice(0,12),
        value: safeNum(b?.value)
      })).filter(b => isFinite(b.value));
      if (!data.length) return;

      ensureSpace(180);
      T(bold, 12, margin, y, title); y -= 12;

      const C = { x: margin, y: y-140, w: colW, h: 140, pad: 16 };
      page.drawRectangle({ x: C.x, y: C.y, width: C.w, height: C.h, borderColor: rgb(0.8,0.8,0.8), borderWidth: 1, color: rgb(1,1,1) });

      const innerW = C.w - C.pad*2, innerH = C.h - C.pad*2;
      const max = Math.max(...data.map(d => d.value), 1);
      const n = data.length;
      const step = innerW / n;
      const bw = Math.max(8, step * 0.6);
      let bx = C.x + C.pad + step*0.2;
      for (const d of data.slice(0, 24)) {
        const hBar = (d.value / max) * innerH;
        page.drawRectangle({ x: bx, y: C.y + C.pad, width: bw, height: hBar, color: rgb(0.2,0.2,0.2) });
        page.drawText(String(d.label), { x: bx, y: C.y + 4, size: 8, font, rotate: undefined });
        bx += step;
      }
      y = C.y - 10;
    }
    function linesChart(title, items){
      const data = (Array.isArray(items) ? items : [])
        .map(p => ({ x: safeStr(p?.x), y: safeNum(p?.y) }))
        .filter(p => isFinite(p.y));
      if (!data.length) return;

      ensureSpace(200);
      T(bold, 12, margin, y, title); y -= 12;

      const C = { x: margin, y: y-160, w: colW, h: 160, pad: 24 };
      page.drawRectangle({ x: C.x, y: C.y, width: C.w, height: C.h, borderColor: rgb(0.8,0.8,0.8), borderWidth: 1, color: rgb(1,1,1) });

      const innerX = C.x + C.pad, innerY = C.y + C.pad;
      const innerW = C.w - C.pad*2, innerH = C.h - C.pad*2;

      const maxY = Math.max(...data.map(d => d.y), 1);
      const minY = Math.min(...data.map(d => d.y), 0);
      const rangeY = Math.max(maxY - minY, 1);

      const n = data.length;
      const stepX = n > 1 ? (innerW / (n - 1)) : innerW;

      drawLineSafe(page, {x: innerX, y: innerY}, {x: innerX, y: innerY + innerH});
      drawLineSafe(page, {x: innerX, y: innerY}, {x: innerX + innerW, y: innerY});

      for (let i=0; i<=4; i++){
        const yy = innerY + (innerH * i/4);
        drawLineSafe(page, {x: innerX, y: yy}, {x: innerX + innerW, y: yy}, 0.5, rgb(0.92,0.92,0.92));
        const val = minY + (rangeY * i/4);
        page.drawText(smartNum(val), { x: innerX - 36, y: yy - 4, size: 8, font, color: rgb(0.3,0.3,0.3) });
      }

      const pts = data.map((d, i) => {
        const x = innerX + i * stepX;
        const yv = innerY + ((d.y - minY) / rangeY) * innerH;
        return { x, y: yv, label: d.x };
      });

      for (let i=1; i<pts.length; i++) drawLineSafe(page, pts[i-1], pts[i], 1.2, rgb(0.2,0.2,0.2));
      for (const p of pts) {
        page.drawRectangle({ x: p.x - 1.5, y: p.y - 1.5, width: 3, height: 3, color: rgb(0.2,0.2,0.2) });
        page.drawText(String(p.label).slice(0,10), { x: p.x - 8, y: innerY - 12, size: 8, font, color: rgb(0.3,0.3,0.3) });
      }

      y = C.y - 10;
    }
    function compositionChart(title, items){
      const raw = (Array.isArray(items) ? items : [])
        .map(p => ({ label: safeStr(p?.label), value: Math.max(0, safeNum(p?.value)) }))
        .filter(p => isFinite(p.value));
      const total = raw.reduce((s,a)=>s+a.value, 0);
      if (!total) return;

      ensureSpace(160);
      T(bold, 12, margin, y, title); y -= 12;

      const C = { x: margin, y: y-120, w: colW, h: 120, pad: 16 };
      page.drawRectangle({ x: C.x, y: C.y, width: C.w, height: C.h, borderColor: rgb(0.8,0.8,0.8), borderWidth: 1, color: rgb(1,1,1) });

      const shades = makeShades(raw.length, rgb);
      const barX = C.x + C.pad;
      const barY = C.y + C.h - C.pad - 18;
      const barW = C.w - C.pad*2;
      const barH = 18;

      let acc = 0;
      raw.slice(0, 24).forEach((seg, i) => {
        const wSeg = barW * (seg.value / total);
        page.drawRectangle({ x: barX + acc, y: barY, width: Math.max(1, wSeg), height: barH, color: shades[i] });
        acc += wSeg;
      });

      let lx = barX, ly = C.y + C.pad + 6;
      const stepX = 160;
      raw.slice(0, 14).forEach((seg, i) => {
        const label = `${seg.label.slice(0,18)} — ${pct(seg.value/total)}`;
        page.drawRectangle({ x: lx, y: ly, width: 10, height: 10, color: shades[i], borderColor: rgb(0.7,0.7,0.7), borderWidth: 0.5 });
        page.drawText(label, { x: lx + 14, y: ly, size: 9, font, color: rgb(0.2,0.2,0.2) });
        lx += stepX;
        if (lx + stepX > C.x + C.w - 10) { lx = barX; ly += 14; }
      });

      y = C.y - 10;
    }
    function makeShades(n, rgbFn){
      const arr=[]; for (let i=0;i<n;i++){ const t=0.2+0.7*(i/Math.max(1,n-1)); arr.push(rgbFn(t,t,t)); } return arr;
    }

    // --- Header
    header(true);

    // --- Summary
    section("Summary");
    y = wrap(font, 12, margin, y, colW, analysis.summary || "-");
    y -= 6;

    // --- Financial Health
    const fh = analysis.financialHealth || {};
    section("Financial Health");
    progress("Profitability", score01(fh.profitabilityScore));
    progress("Liquidity",     score01(fh.liquidityScore));
    progress("Concentration Risk (lower is better)", 1 - score01(fh.concentrationRiskScore));
    if (Array.isArray(fh.anomalyFlags) && fh.anomalyFlags.length) {
      y = wrap(font, 11, margin, y, colW, "Anomalies: " + fh.anomalyFlags.join("; "));
      y -= 4;
    }
    y = wrap(font, 11, margin, y, colW, "Rationale: " + safeStr(fh.rationale));
    y -= 8;

    // --- Key Amounts
    const amounts = Array.isArray(analysis.amounts) ? analysis.amounts : [];
    if (amounts.length) {
      section("Key Amounts");
      for (const a of amounts.slice(0, 10)) {
        const line = `${safeStr(a?.label || "Amount")}: ${fmtNum(a?.value)} ${safeStr(a?.currency)}`;
        y = wrap(font, 11, margin, y, colW, line) - 2;
        ensureSpace(22);
      }
      y -= 6;
    }

    // --- Risks
    const risks = Array.isArray(analysis.risks) ? analysis.risks : [];
    section("Risks");
    if (risks.length) {
      for (const r of risks.slice(0, 12)) {
        const line = `• [${safeStr(r?.severity).toUpperCase()}] ${safeStr(r?.risk)} — ${safeStr(r?.mitigation)}`;
        y = wrap(font, 11, margin, y, colW, line) - 2;
        ensureSpace(22);
      }
    } else {
      y = wrap(font, 11, margin, y, colW, "No major risks identified.") - 2;
    }
    y -= 6;

    // --- Actions
    const actions = Array.isArray(analysis.actions) ? analysis.actions : [];
    section("Actions");
    if (actions.length) {
      for (const a of actions.slice(0, 12)) {
        const line = `• [P${safeInt(a?.priority)}] ${safeStr(a?.action)}${a?.owner ? " | Owner: "+safeStr(a.owner) : ""}${isFinite(a?.dueDays)? " | Due: "+a.dueDays+"d" : ""}`;
        y = wrap(font, 11, margin, y, colW, line) - 2;
        ensureSpace(22);
      }
    } else {
      y = wrap(font, 11, margin, y, colW, "No immediate actions suggested.") - 2;
    }
    y -= 8;

    // --- Charts
    const bars = analysis?.charts?.bars;
    if (Array.isArray(bars) && bars.length) barsChart("Chart: Bars", bars);

    const lines = analysis?.charts?.lines;
    if (Array.isArray(lines) && lines.length) linesChart("Chart: Trend", lines);

    const pie = analysis?.charts?.pie;
    if (Array.isArray(pie) && pie.length) compositionChart("Chart: Composition", pie);

    // --- Footer
    HR(60);
    T(font, 10, margin, 46, `${brand.company || "BizDoc"} • Confidence: ${pct(analysis.confidence)}`);
    T(font, 10, width - margin - textWidth(font, 10, today()), 46, today());

    const bytes = await pdf.save();
    res.setHeader("Content-Type", "application/pdf");
    res.setHeader("Content-Disposition", 'attachment; filename="bizdoc_report.pdf"');
    return res.status(200).send(Buffer.from(bytes));
  } catch (e) {
    // Return the error string so you can see it with curl if anything ever breaks again
    return res.status(500).json({ ok:false, error: String(e?.message || e) });
  }
}

/* ---------- utils ---------- */
function clamp01(x){ const n = Number(x); return isFinite(n) ? Math.max(0, Math.min(1, n)) : 0; }
function score01(s){ const n = Number(s); return isFinite(n) ? Math.max(0, Math.min(1, n/5)) : 0; }
function pct(n){ return isFinite(n) ? Math.round(n*100)+"%" : "-"; }
function fmtNum(n){ const v = Number(n); return isFinite(v) ? new Intl.NumberFormat("en-US",{maximumFractionDigits:2}).format(v) : "-"; }
function smartNum(n){ const v = Number(n); if (!isFinite(v)) return "-"; const k=Math.abs(v)>=1000?1:0; return new Intl.NumberFormat("en-US",{maximumFractionDigits: k?0:2}).format(v); }
function safeInt(n){ const v = parseInt(n,10); return isFinite(v) ? v : "-"; }
function safeNum(n){ const v = Number(n); return isFinite(v) ? v : 0; }
function safeStr(s){ return (s==null) ? "" : String(s); }
function today(){ return new Date().toISOString().slice(0,10); }

async function readBody(req){
  const chunks=[]; for await (const c of req) chunks.push(c);
  try { return JSON.parse(Buffer.concat(chunks).toString("utf8")||"{}"); } catch { return {}; }
}
